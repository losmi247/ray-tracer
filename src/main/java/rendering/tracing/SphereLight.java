package rendering.tracing;

import rendering.utility.RTColor;
import rendering.utility.Vector3D;

import java.util.Random;

/**
 * Class for a light source distributed
 * over the surface of a sphere with a
 * given radius. Used for rendering
 * soft shadows.
 *
 * The sphere light extends the point light
 * and overrides the 'lightSourceOccluded'
 * method so that it can simulate soft shadows.
 *
 * Sphere light sources have XML description
 * nodes named "sphere-light".
 */

public class SphereLight extends PointLight implements Light {
    private final double radius;

    /// number of shadow rays to cast when checking if light source is occluded
    public static final int numberOfShadowRays = 5;

    /**
     * Constructors
     */
    public SphereLight(Vector3D position, RTColor lightSpecularColor, double intensity, double radius) {
        super(position, lightSpecularColor, intensity);
        this.radius = radius;
    }

    /**
     * Methods
     */
    /*
       Method that spawns and casts the necessary shadow rays to check how much
       this light source is occluded at the given intersection point by any of
       the RTShape's in the given scene.

       Multiple shadow rays are cast from the intersection point to random points
       on the surface of the sphere light. The returned occlusion coefficient is
       the proportion of the cast shadow rays that do not hit an RTShape before
       reaching the target point on surface of the sphere light.
     */
    @Override
    public double getOcclusionCoefficient(Intersection intersection, Scene scene) {
        Random rnd = new Random();
        int numberOfNonOccludedShadowRays = 0;
        for(int i = 0; i < SphereLight.numberOfShadowRays; i++) {
            /// Get a random point on the surface of a sphere of radius same as this light source's and centered at origin,
            /// then translate it by center of the sphere light source as a Vector3D.
            Vector3D randomPointOnLightSource = (SphereLight.getRandomPointOnUnitSphere(rnd)).scaled(this.radius).translate(super.getPosition());
            /// cast a shadow ray from the intersection point to that random point
            ShadowRay shadowRay = new ShadowRay(intersection, randomPointOnLightSource);

            if(!shadowRay.targetPointOccluded(scene)) {
                numberOfNonOccludedShadowRays++;
            }
        }

        return (double) numberOfNonOccludedShadowRays / (double) SphereLight.numberOfShadowRays;
    }

    /**
     * Static Utility Methods
     */
    /*
       Method that generates a random point on a unit sphere at origin.
       Each coordinate is generated by sampling the standard Gaussian
       distribution N(0,1), after which coordinates are normalised.
       https://math.stackexchange.com/questions/1585975/how-to-generate-random-points-on-a-sphere
     */
    private static Vector3D getRandomPointOnUnitSphere(Random rnd) {
        double x = rnd.nextGaussian();
        double y = rnd.nextGaussian();
        double z = rnd.nextGaussian();

        /// TODO - what if x=y=z=0

        return (new Vector3D(x,y,z)).normalised();
    }
}
